{"version":3,"file":"transform-shipping-methods.js","sources":["../../src/api/errors/errors.ts","../../src/signals/EstimateShippingMethodsSignal.ts","../../src/signals/RegionsSignal.ts","../../src/api/utils/enqueueRequest.ts","../../src/api/utils/filterControlledErrors.ts","../../src/api/utils/dispatchApiCall.ts","../../src/data/transforms/transform-shipping-methods.ts"],"sourcesContent":["import { FetchQueryError } from '@adobe/fetch-graphql';\n\nexport class FetchError extends Error {\n  constructor(reasons: FetchQueryError) {\n    super(reasons.map((e: any) => e.message).join(' '));\n    this.name = 'FetchError';\n  }\n}\n\nexport class InvalidArgument extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InvalidArgument';\n  }\n}\n\nexport class UnexpectedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'UnexpectedError';\n  }\n}\n\nexport class MissingCart extends InvalidArgument {\n  constructor() {\n    super('Cart ID is required');\n  }\n}\nexport class MissingEmail extends InvalidArgument {\n  constructor() {\n    super('Email is required');\n  }\n}\n\nexport class MissingPaymentMethod extends InvalidArgument {\n  constructor() {\n    super('Payment method code is required');\n  }\n}\n\nexport class MissingBillingAddress extends InvalidArgument {\n  constructor() {\n    super('Billing address is required');\n  }\n}\n\nexport class MissingCountry extends InvalidArgument {\n  constructor() {\n    super('Country Code is required');\n  }\n}\n","import { signal } from '@preact/signals';\nimport { ShippingMethod } from '@/checkout/data/models';\n\nexport const estimateShippingMethodsSignal = signal<{\n  pending: boolean;\n  data?: ShippingMethod[];\n}>({ pending: false, data: undefined });\n","import { AddressFormType } from '@/checkout/data/models';\nimport { Region as RegionModel } from '@/checkout/data/models/region';\nimport { signal } from '@preact/signals';\n\nexport const regionsSignal = signal<{\n  addressType?: AddressFormType;\n  country?: string;\n  selectedRegion?: string;\n  selectedRegionId?: string;\n  pending: boolean;\n  data?: RegionModel[];\n}>({ pending: false, data: undefined });\n","const requestsQueue: (() => Promise<any>)[] = [];\n\nexport function enqueueRequest<T>(requestFn: () => Promise<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    requestsQueue.push(requestFn);\n\n    const waitForTurnAndSendRequest = () => {\n      if (requestsQueue[0] === requestFn) {\n        requestFn()\n          .then(resolve)\n          .catch(reject)\n          .finally(() => requestsQueue.shift());\n      } else {\n        setTimeout(waitForTurnAndSendRequest, 100);\n      }\n    };\n\n    waitForTurnAndSendRequest();\n  });\n}\n","import { FetchQueryError } from '@adobe/fetch-graphql';\n\ntype ErrorPath = (string | number)[];\n\nexport type ErrorWithPath = FetchQueryError[number] & {\n  path?: ErrorPath;\n};\n\nconst controlledErrorProps: string[] = ['sender_email', 'recipient_email'];\n\n/**\n * Filters out errors with known paths from a list of errors generated by a GraphQL query.\n *\n * Known issue: The query does not differentiate between physical and virtual gift cards, leading\n * to errors for physical ones as they don't have 'sender_email' and 'recipient_email' properties.\n *\n * @param {ErrorWithPath[]} errors - Array of errors to be filtered.\n * @return {ErrorWithPath[]} Uncontrolled (unexpected) errors not matching predefined paths.\n */\n\nexport function filterControlledErrors(errors: ErrorWithPath[]) {\n  return errors.filter(\n    (error) =>\n      !error.path ||\n      !controlledErrorProps.some((controlledErrorProp) => {\n        return error.path?.at(-1) === controlledErrorProp;\n      })\n  );\n}\n","import { FetchError, fetchGraphQl } from '@/checkout/api';\nimport { handleNetworkError } from '@/checkout/lib/network-error';\nimport {\n  cartSignal,\n  regionsSignal,\n  estimateShippingMethodsSignal,\n  customerSignal,\n} from '@/checkout/signals';\n\nimport { FetchOptions, FetchQueryError } from '@adobe/fetch-graphql';\nimport { enqueueRequest } from '@/checkout/api/utils/enqueueRequest';\nimport { filterControlledErrors } from '@/checkout/api/utils/filterControlledErrors';\n\nconst signalTypes = {\n  cart: cartSignal,\n  regions: regionsSignal,\n  estimateShippingMethods: estimateShippingMethodsSignal,\n  customer: customerSignal,\n};\n\ntype SignalTypesType = typeof signalTypes;\ntype SignalTypesKeys = keyof SignalTypesType;\ntype SignalDataMap = {\n  [K in SignalTypesKeys]: SignalTypesType[K]['value']['data'];\n};\ntype DispatchApiCallParams<T extends SignalTypesKeys> = {\n  type: 'query' | 'mutation';\n  query: string;\n  options?: FetchOptions;\n  path: string;\n  signalType: T;\n  transformer?: (data: any) => SignalDataMap[T];\n};\n\nexport function getValueAtPath(obj: any, path: string) {\n  return path\n    .split('.')\n    .reduce(\n      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : undefined),\n      obj\n    );\n}\n\nconst latestCall: Record<SignalTypesKeys, Symbol | null> = {\n  cart: null,\n  customer: null,\n  estimateShippingMethods: null,\n  regions: null,\n};\n\nasync function dispatchApiCall<T extends SignalTypesKeys>(\n  params: DispatchApiCallParams<T>\n): Promise<SignalDataMap[T]> {\n  const { query, options, path, signalType, type, transformer } = params;\n  const signal = signalTypes[signalType];\n  const currentCall = Symbol();\n\n  latestCall[signalType] = currentCall;\n\n  signal.value = { ...signal.value, pending: true };\n\n  try {\n    const { data, errors } = await (type === 'mutation'\n      ? enqueueRequest(() =>\n          fetchGraphQl(query, options).catch(handleNetworkError)\n        )\n      : fetchGraphQl(query, {\n          method: 'GET',\n          cache: 'no-cache',\n          ...options,\n        }).catch(handleNetworkError));\n\n    if (errors) {\n      const uncontrolledErrors = filterControlledErrors(errors);\n\n      if (uncontrolledErrors.length > 0) {\n        throw new FetchError(uncontrolledErrors as FetchQueryError);\n      }\n    }\n\n    let result = getValueAtPath(data, path);\n    if (result === undefined) throw new Error(`No data found at path: ${path}`);\n    if (transformer) result = transformer(result);\n\n    signal.value = { ...signal.value, data: result };\n\n    // to avoid flickering of the pending state when there are multiple sequential calls\n    setTimeout(() => {\n      signal.value = {\n        ...signal.value,\n        pending:\n          latestCall[signalType] === currentCall ? false : signal.value.pending,\n      };\n    }, 0);\n\n    return result;\n  } catch (error: any) {\n    if (error.name === 'AbortError') return;\n    signal.value = { ...signal.value, pending: false };\n    throw error;\n  }\n}\n\nexport { dispatchApiCall };\n","import { ShippingMethod } from '@/checkout/data/models/shipping-method';\nimport { GetCartQuery } from '@/checkout/__generated__/types';\nimport { isNullish } from '@/checkout/utils/isNullish';\n\ntype Cart = NonNullable<GetCartQuery['cart']>;\ntype ShippingAddresses = Cart['shipping_addresses'];\ntype ShippingAddress = NonNullable<NonNullable<ShippingAddresses>[number]>;\ntype AvailableShippingMethods = ShippingAddress['available_shipping_methods'];\ntype AvailableShippingMethod = NonNullable<AvailableShippingMethods>[number];\ntype SelectedShippingMethod = ShippingAddress['selected_shipping_method'];\n\ntype FilteredShippingMethod = Omit<\n  NonNullable<AvailableShippingMethod>,\n  'method_code' | 'method_title' | 'amount'\n> & {\n  method_code: string;\n  method_title: string;\n  amount: {\n    value: number;\n    currency: string;\n  };\n};\n\nconst byPrice = (a: ShippingMethod, b: ShippingMethod) =>\n  a.amount.value - b.amount.value;\n\nconst isValid = (method: AvailableShippingMethod | SelectedShippingMethod) => {\n  if (!method) return false;\n  if (!method.method_code || !method.method_title) return false;\n  if (isNullish(method.amount.value) || !method.amount.currency) return false;\n  return true;\n};\n\nconst buildShippingMethod = (data: FilteredShippingMethod): ShippingMethod => {\n  return {\n    amount: {\n      value: data.amount.value,\n      currency: data.amount.currency,\n    },\n    title: data.method_title,\n    code: data.method_code,\n    carrier: {\n      code: data.carrier_code,\n      title: data.carrier_title,\n    },\n    value: `${data.carrier_code} - ${data.method_code}`,\n  };\n};\n\nexport const transformSelectedShippingMethod = (\n  data: SelectedShippingMethod\n): ShippingMethod | undefined => {\n  if (!isValid(data)) return;\n  return buildShippingMethod(data as FilteredShippingMethod);\n};\n\nexport const transformAvailableShippingMethod = (\n  data: AvailableShippingMethod\n): ShippingMethod | undefined => {\n  if (!isValid(data)) return;\n  return buildShippingMethod(data as FilteredShippingMethod);\n};\n\nexport const transformShippingMethods = (\n  data: AvailableShippingMethods\n): ShippingMethod[] | undefined => {\n  if (!data) return;\n\n  return data\n    .filter(isValid)\n    .map((method) => buildShippingMethod(method as FilteredShippingMethod))\n    .sort(byPrice);\n};\n"],"names":["FetchError","Error","constructor","reasons","map","e","message","join","name","InvalidArgument","UnexpectedError","MissingCart","MissingEmail","MissingPaymentMethod","MissingBillingAddress","MissingCountry","estimateShippingMethodsSignal","signal","pending","data","undefined","regionsSignal","requestsQueue","enqueueRequest","requestFn","Promise","resolve","reject","push","waitForTurnAndSendRequest","then","catch","finally","shift","setTimeout","controlledErrorProps","filterControlledErrors","errors","filter","error","path","some","controlledErrorProp","at","signalTypes","cart","cartSignal","regions","estimateShippingMethods","customer","customerSignal","getValueAtPath","obj","split","reduce","acc","part","latestCall","dispatchApiCall","params","query","options","signalType","type","transformer","currentCall","Symbol","value","fetchGraphQl","handleNetworkError","method","cache","uncontrolledErrors","length","result","byPrice","a","b","amount","isValid","method_code","method_title","isNullish","currency","buildShippingMethod","title","code","carrier","carrier_code","carrier_title","transformSelectedShippingMethod","transformShippingMethods","sort"],"mappings":"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"}